#!/usr/bin/env ruby

require 'trollop'
require 'pcap_tools'
require 'cast'
require 'pp'
#require 'qreplay'
require_relative '../lib/qreplay'

OPT = Trollop::options do
  opt :capture_time, 'Capture time length in seconds', :default => 60.0
  opt :port, 'Capture/replay traffic to port', :default => 80
  opt :host, 'Replay host', :default => '0.0.0.0'
  opt :req_sec, 'Requests per second for replays', :default => 20
  opt :total_requests, 'Total replay requests to send', :default => 10000
  opt :capture_file, 'Output file', :default => './qreplay.sesslog'
  opt :pcap_file, 'Temporary intermediate pcap file path', :default => './qreplay.pcap'
  opt :tshark_binary, 'TShark binary file location', :default => 'tshark'
  opt :dumpcap_binary, 'dumpcap binary file location', :default => 'dumpcap'
  opt :httperf_binary, 'httperf binary file location', :default => 'httperf'
end

COMMANDS = ['capture', 'replay', 'transform', 'capture-only']

def check_binary(name, binary)
  #r = Cast::local('which #{binary}')
  #raise "Could not find #{name} binary at path #{binary}" unless r == 0
end

class Printer
  def initialize(capture_file)
    @counter = 0
	@fhandle = File.open(capture_file, 'w+')
  end
  
  def process_stream stream
    stream.each do |index, req, resp|
	  body = req.body
      @fhandle.puts "#{req.path} method=#{req.method} contents=#{body.inspect}"
	  @fhandle.puts "\n"
      @counter += 1
    end
  end
  
  def finalize
    puts "Number of HTTP Requests : #{@counter}"
	@fhandle.close
  end
end

def transform_pcap(tshark_binary, pcap_file, capture_file)
  puts "Writing HTTP requests with #{tshark_binary} from #{pcap_file} to #{capture_file}"
  check_binary('tshark', tshark_binary)
  
  processor = QReplay::TcpProcessor.new
  processor.add_stream_processor(QReplay::TcpStreamRebuilder.new)
  processor.add_stream_processor(QReplay::HttpExtractor.new)
  processor.add_stream_processor(Printer.new(capture_file))

  begin
    PcapTools::Loader::load_file(pcap_file, {}) do |index, packet|
      begin
        processor.inject index, packet
      rescue Exception => e
        puts "Skipping unparseable request:"
        puts e.message
        pp e.backtrace
      end
    end
  rescue Exception => e
    puts "Exception while parsing tshark output, saving current requests and bailing out."
	puts e.message
	pp e.backtrace
  end

  processor.finalize
end

def capture_pcap(port, pcap_file, capture_time, dumpcap_binary)
  check_binary('dumpcap', dumpcap_binary)

  puts "Capturing HTTP on port #{port} to file #{pcap_file} for #{capture_time} seconds"
  cmd = "#{dumpcap_binary} -w #{pcap_file} -f 'tcp port #{port}' -a duration:#{capture_time.to_i}"
  puts cmd
  system(cmd)
end

def replay_httperf(binary, req_sec, total_requests, capture_file, host, port)
  check_binary('httperf', binary)
  thinktime = 0.1
  cmd = "#{binary} --server=#{host} --port=#{port} --rate=#{req_sec} --verbose --wsesslog=#{total_requests},#{thinktime},#{capture_file} --hog"
  puts cmd
  system(cmd)
end

command = ARGV[0]
case command
  when 'capture'
    capture_pcap(OPT[:port], OPT[:pcap_file], OPT[:capture_time], OPT[:dumpcap_binary])
    transform_pcap(OPT[:tshark_binary], OPT[:pcap_file], OPT[:capture_file])
  when 'capture-only'
    capture_pcap(OPT[:port], OPT[:pcap_file], OPT[:capture_time], OPT[:dumpcap_binary])
  when 'transform'
    transform_pcap(OPT[:tshark_binary], OPT[:pcap_file], OPT[:capture_file])
  when 'replay'
    replay_httperf(OPT[:httperf_binary], OPT[:req_sec], OPT[:total_requests], OPT[:capture_file], OPT[:host], OPT[:port])
  else raise "Command must be #{COMMANDS.join('|')}"
end

